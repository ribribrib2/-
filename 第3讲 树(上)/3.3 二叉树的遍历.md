## 二叉树的遍历
### 先序遍历
遍历过程为:
- 访问根结点;
- 先序遍历其左子树;
- 先序遍历其右子树.

![](http://qiniu.rearib.top/20191912/1453-y.png)

### 中序遍历
遍历过程为:
- 中序遍历其左子树;
- 访问根结点;
- 中序遍历其右子树.

![](http://qiniu.rearib.top/20191912/1454-A.png)

### 后序遍历
遍历过程为:
- 后序遍历其左子树;
- 后序遍历其右子树;
- 访问根结点.

![](http://qiniu.rearib.top/20191912/1456-h.png)

**先序、中序和后序遍历过程:遍历过程中经过结点的路线样,只是访问各结点的时机不同.**

**上面三种方法使用的都是递归方法**

## 二叉树的非递归遍历
- 中序遍历非递归遍历算法:使用堆栈

1. 遇到一个结点,就把它压栈,并去遍历它的左子树
2. 当左子树遍历结束后,从栈顶弹出这个结点并访问它;
3. 然后按其右指针再去中序遍历该结点的右子树.

![](http://qiniu.rearib.top/20191912/1501-I.png)

|次数|堆栈状态|结果|
|-|-|-|
|1|A||
|2|AB||
|3|ABD||
|4|AB|D|
|5|A|DB|
|6|AF|DB|
|7|AFE|DB|
|8|AF|DBE|
|9|A|DBEF|
|10||DBEFA|
|11|C|DBEFA|
|12|CG|DBEFA|
|13|C|DBEFAG|
|14|CH|DBEFAG|
|15|C|DBEFAGH|
|16||DBEFAGHC|
|17|I|DBEFAGHC|
|18||DBEFAGHCI|

![](http://qiniu.rearib.top/20191912/1501-T.png)

### 思考先序后序的非递归遍历程序
[链接](https://www.icourse163.org/learn/ZJU-93001?tid=1003013004#/learn/content?type=detail&id=1004242204&cid=1005239456)

### 层序遍历(第四种遍历方法)
二叉树遍历的核心问题:二维结构的线性化

- 从结点访问其左、右儿子结点
- 访问左儿子后,右儿子结点怎么?
  1. 需要一个存储结构保存暂时不访问的结点
  2. 存储结构:堆栈、队列

- 用队列实现遍历
遍历从根结点开始,首先将根结点入队,然后开始执行循环:结点出队、访问该结点、其左右儿子入队

![](http://qiniu.rearib.top/20191912/1521-y.png)

- 层序基本过程:先根结点入队,然后:
1. 从队列中取出一个元素
2. 访问该元素所指结点;
3. 若该元素所指结点的左、右孩子结点非空,则将其左、右孩子的指针顺序入队.

![](http://qiniu.rearib.top/20191912/1521-i.png)

### 输出二叉树中的叶子结点
![](http://qiniu.rearib.top/20191912/1524-Y.png)

### 求二叉树的高度
![](http://qiniu.rearib.top/20191912/1525-Y.png)

### 二元运算表达式树及其遍历
![](http://qiniu.rearib.top/20191912/1527-9.png)

最终表达式: (a+b*c)+(d*e+f)*g, 可以观察到中序表达式是错误的, 因为中缀表达式会受到运算符优先级的影响, 解决办法就是出左子树的时候先出一个(,右子树结束的时候加一个).

### 由两种遍历序列确定二叉树
**必须要有中序序列**

![](http://qiniu.rearib.top/20191912/1549-P.png)

- 先序和中序遍历序列来确定一棵二叉树

![](http://qiniu.rearib.top/20191912/1550-q.png)

- 例题

![](http://qiniu.rearib.top/20191912/1601-8.png)

![](http://qiniu.rearib.top/20191912/1603-0.png)


