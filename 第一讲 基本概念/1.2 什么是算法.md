## 算法的定义
- 一个有限指令集
- 接受一些输入(有些情况下不需要输入) 
- 产生输出 
- 一定在有限步骤之后终止
- 每一条指令必须:
  1. 有充分明确的目标,不可以有歧义
  2. 计算机能处理的范围之内
  3. 描述应不依赖于任何一种计算机语言以及具体的实现手段

### 选择排序算法的伪码描述
![](http://qiniu.rearib.top/20191910/2030-9.png)

**抽象**
- list到底是数组还是链表(虽然看上去很像数组)? 
- swap用函数还是用宏去实现?

### 什么是好的算法?
- 空间复杂度S(n)——根据算法写成的程序在执行时**占用存储单元的长度**.这个长度往往与输入数据的规模有关.空间复杂度过高的算法可能导致使用的内存超限,造成程序非正常中断.
- 时间复杂度T(m)—根据算法写成的程序在执行时**耗费时间的长度**.这个长度往往也与输入数据的规模有关.时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果.

例如之前打印N的函数在内存中占用空间大小很大, S(n)=C*N,且随着N增大而增大.而多项式那个例子中因为机器运行加减法比乘除法快很多, 所以去数做了多少次乘除法, 加减法忽略不计, 第一个种方法中有pow函数:

![](http://qiniu.rearib.top/20191910/2040-m.png)

### 在分析一般算法的效率时,我们经常关注下面两种复杂度
![](http://qiniu.rearib.top/20191910/2041-c.png)

### 分析“二分法”
```
查找算法中的“二分法”是这样定义的：

给定N个从小到大排好序的整数序列List[]，以及某待查找整数X，我们的目标是找到X在List中的下标。即若有List[i]=X，则返回i；否则返回-1表示没有找到。

二分法是先找到序列的中点List[M]，与X进行比较，若相等则返回中点下标；否则，若List[M]>X，则在左边的子系列中查找X；若List[M]<X，则在右边的子系列中查找X。

试写出算法的伪码描述，并分析最坏、最好情况下的时间、空间复杂度。
```
- 时间上：
1. 最好情况应当是第一次中值即取到,那么T(n) = O(1)
2. 最差情况则是最多次二分才取到/未找到:

![](https://nos.netease.com/edu-image/028e9d27b9614f24a05810d60b642f20.png?imageView) 
- 空间上：
1. 不使用递归则会是稳定复杂度S(n) = O(1)
 
**对于复杂度只是需要知道它的一个增长趋势, 并不是一定要精确计算出复杂度**

### 复杂度的渐进表示法
![](http://qiniu.rearib.top/20191910/2111-o.png)

![](http://qiniu.rearib.top/20191910/2111-W.png)

- 小窍门

![](http://qiniu.rearib.top/20191910/2112-b.png)












 