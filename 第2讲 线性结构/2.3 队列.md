## 什么是队列
队列(Queue):具有一定操作约束的**线性表**
- 插入和删除操作:只能在一端插入,而在另一端删除.
- 数据插入:入队列(AddQ)
- 数据删除:出队列(DeleteQ)
- 先来先服务
- 先进先出:FIFO

### 队列的抽象数据类型描述
![](http://qiniu.rearib.top/20191911/1533-p.png)

### 队列的顺序存储实现
队列的顺序存储结构通常由一个**一维数组**和一个记录队列头元素位置的变量**front**以及一个记录队列尾元素位置的变量**rear**组成.

![](http://qiniu.rearib.top/20191911/1535-E.png)

![](http://qiniu.rearib.top/20191911/1536-a.png)

#### 顺环队列
![](http://qiniu.rearib.top/20191911/1537-b.png)

Front==Rear:队列是空还是满?
- 这种方案:堆栈空和满的判别条件是什么?
- 为什么会出现空、满无法区分?根本原因?

解决方案:
- 使用额外标记:Size(当前队列元素个数)或者tag(标记最后一个操作是插入还是删除)域
- 仅使用n-1个数组空间

![](http://qiniu.rearib.top/20191911/1544-B.png)

### 队列的链式存储实现
队列的链式存储结构也可以用一个单链表实现.插入和删除操作分别在链表的两头进行;队列指针front和rear应该分别指向链表的哪一头?

链表的头做插入删除都方便, 链表的尾做插入方便, 删除不方便
所以front在头, rear在尾

![](http://qiniu.rearib.top/20191911/1549-O.png)

#### 不带头结点的链式队列出队操作的一个示例:
![](http://qiniu.rearib.top/20191911/1549-J.png)

#### 题目
- 在一个链表表示的队列中， f和r分别指向队列的头和尾。下列哪个操作能正确地将s结点插入到队列中：r->next=s; r=s; 

由于是链表, 所以链表的头做f, 链表的尾做r, 所以数据插入式在链表的尾插入, r.next = s, 同时要把s赋给r. 

- 如何用两个堆栈模拟实现一个队列?  如果这两个堆栈的容量分别是m和n（m>n)，你的方法能保证的队列容量是多少？

最大应该是2n, 比如m n两个栈可以先往n里push n个元素, 再将n个元素出栈, push入m. 就完成了n个元素转化为队列的要求, 再往n里push n个元素, 可等m中所有的元素pop完毕, 再执行上一步的操作

